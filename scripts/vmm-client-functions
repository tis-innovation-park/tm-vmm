#
#                                                                   
#                   Testing Machine
#                      
#   Copyright (C) 2012, 2013 TIS Innovation Park
#                                                                   
# This program is free software; you can redistribute it and/or     
# modify it under the terms of the GNU General Public License       
# as published by the Free Software Foundation; either version 3    
# of the License, or any later version.                             
#                                                                   
#                                                                   
# This program is distributed in the hope that it will be useful,   
# but WITHOUT ANY WARRANTY; without even the implied warranty of    
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     
# GNU General Public License for more details.                      
#                                                                   
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software       
# Foundation, Inc., 51 Franklin Street, Boston,            
# MA  02110-1301, USA.                                              
#

declare -a SCRIPTS_TO_EXECUTE
export SCRIPTS_TO_EXECUTE


ANDROID_SPEC_FILE=$(dirname $0)/../share/testingmachine/scripts/vmm-client-android-specific
if [ -f $ANDROID_SPEC_FILE ]
then
    source $ANDROID_SPEC_FILE
else
    echo "Can't find $ANDROID_SPEC_FILE"
    exit 1
fi

list_vbox_machines()
{
    debug "Listing vbox machines"
    VB_NAMES=$(vboxmanage list vms | awk 'BEGIN { FS="\""}  { printf "%s;", $2}' | sed 's,\",,g' )
    SAVED_FS=$IFS
    export IFS=";"
    for VB_NAME in $VB_NAMES
    do
	FOUND=false
	if [ "$VB_NAME" != "" ]
	then
	    SUB_CLIENTS=$(find $ETC_DIRS -name *.conf 2>/dev/null | grep "clients/" | xargs grep -l $VB_NAME)
	    echo  "  |--$VB_NAME  "
	    if [ "$SUB_CLIENTS" != "" ]
	    then
		for vb in $SUB_CLIENTS
		do
#		echo " ---- $VB_NAME"
		    VB_SHORT_NAME=$(basename $vb)
		    echo "     |--$VB_SHORT_NAME (client)"  
		    FOUND=true
		done
#	    if [ "$FOUND" = "false" ]
#	    then
#		echo "      not in use"
#	    fi
#	    else
#		echo ""
	    fi
	else
	    echo "   no virtualbox machines found"
	fi
    done
    IFS=$SAVED_IFS
}


list_android_machines()
{
    check_android_settings hard
    RET=$?
    if [ $RET -ne 0 ] ; then return $RET; fi

    debug "Listing android machines"
#    VB_NAMES=$(find  ${ANDROID_AVD_DIR}/* -prune -name "*.ini" | sed 's,\.ini,,g')
    VB_NAMES=$($ANDROID list avd | grep Name | sed 's,[ \t]*Name: ,,g')
    for VB_NAME_LONG in $VB_NAMES
    do
	VB_NAME=$(basename $VB_NAME_LONG)
	FOUND=false
	if [ "$VB_NAME" != "" ]
	then
	    echo  "  |--$VB_NAME  "
	    SUB_CLIENTS=$(find $ETC_DIRS -name *.conf 2>/dev/null | grep "clients/" | xargs grep -l $VB_NAME)

#	    echo "SUB_CLIENTS: $SUB_CLIENTS"
	    if [ "$SUB_CLIENTS" != "" ]
	    then
		for vb in $SUB_CLIENTS
		do
#		echo " ---- $VB_NAME"
		    VB_SHORT_NAME=$(basename $vb)
		    echo "     |--$VB_SHORT_NAME  (client)"  
		    FOUND=true
		done
#	    if [ "$FOUND" = "false" ]
#	    then
#		echo "      not in use"
#	    fi
	    fi
	else
	    echo "   no android machines found"
	fi
    done

}




list_machines()
{
    debug "Listing available machines:"
    echo "Available machines:"
    echo "  VirtualBox"
    list_vbox_machines
    echo "  Android"
    list_android_machines
}

list_clients()
{
    debug_enter "Listing available clients"

    echo "Available clients:"
    for d in $ETC_DIRS
    do
	debug_enter " entering dir $d"
	debug "  in dir $d"
	for i in $(find $d/clients -name "*.conf" 2>/dev/null)
	do
	    debug_enter " using file $i"
	    debug "    file: $i"
	    TYPE=$(grep VM_TYPE "$i" | sed 's,[ ]*VM_TYPE=,,g' | sed 's,\",,g')
	    echo -n "   " 
	    printf "%s " $(basename $i | sed 's,\.conf,,g' )
	    printf " [%.12s] ($i)\n" $TYPE
	    debug_leave " "
	done
	debug_leave " "
    done

    debug_leave "list_clients"
}

list_running_vbox()
{
    echo "  VirtualBox"
    VB_NAMES=$(vboxmanage list vms | awk 'BEGIN { FS="\""}  { printf "%s;", $2}' | sed 's,\",,g' )
    if [ "$VB_NAME" != "" ]
    then
        SAVED_FS=$IFS
    	export IFS=";"
	for i in $VB_NAME
	do
	    FOUND=0
	    for dir in  $ETC_DIRS
	    do
		if [ -d $dir ]
		then
		    for vb in $(find $dir/clients -name *.conf | xargs grep -l $i )
		    do
			VB_SHORT_NAME=$(basename $vb | sed 's,\.conf,,g')
			echo "  |--$VB_SHORT_NAME  [$vb] (machine: $i )"  
			FOUND=1
		    done
		fi
	    done
	    if [ $FOUND -eq 0 ] ; then echo "    * avd is not in use"; fi
	done
    else
	echo "   no virtualbox machines currently running"
    fi
    IFS=$SAVED_IFS
}

list_running_vbox_machines()
{
    echo "  VirtualBox"
    VB_NAME=$(vboxmanage list runningvms | awk ' { printf "%s", $1}' | sed 's,\",,g')
    if [ "$VB_NAME" != "" ]
    then
        SAVED_FS=$IFS
    	export IFS=";"
	for i in $VB_NAME
	do
	    echo "  |--$i  "
	    FOUND=0
	    for dir in  $ETC_DIRS
	    do
		if [ -d $dir ]
		then
		    for vb in $(find $dir/clients -name *.conf | xargs grep -l $i )
		    do
			VB_SHORT_NAME=$(basename $vb)
			echo "    |--$VB_SHORT_NAME  [$vb] (client)"  
			FOUND=1
		    done
		fi
	    done
	    if [ $FOUND -eq 0 ] ; then echo "    * avd is not in use"; fi
	done
	IFS=$SAVED_IFS
    else
	echo "   no virtualbox machines currently running"
    fi
}

list_running_android()
{
    echo "  Android"
    VB_NAME=$(get_connected_avds_ports)
    if [ "$VB_NAME" != "" ]
    then
	for i in $VB_NAME
	do
	    AVD_NAME=$(get_avd_name_for_port $i)
	    FOUND=0
	    for dir in  $ETC_DIRS
	    do
		if [ -d $dir ]
		then
		    for vb in $(find $dir/clients -name *.conf | xargs grep -l $AVD_NAME )
		    do
			VB_SHORT_NAME=$(basename $vb | sed 's,\.conf,,g')
			echo "  |--$VB_SHORT_NAME  [$vb] (machine: $(get_avd_name_for_port $i))"  
			FOUND=1
		done
		fi
	    done
	done
    else
	echo "   no virtualbox machines currently running"
    fi
}

list_running_android_machines()
{
    echo "  Android"
    VB_NAME=$(get_connected_avds_ports)
    if [ "$VB_NAME" != "" ]
    then
	for i in $VB_NAME
	do
	    AVD_NAME=$(get_avd_name_for_port $i)
	    echo "  |-- $AVD_NAME  (using port $i)"

	    FOUND=0
	    for dir in  $ETC_DIRS
	    do
		if [ -d $dir ]
		then
		    for vb in $(find $dir/clients -name *.conf | xargs grep -l $AVD_NAME )
		    do
			VB_SHORT_NAME=$(basename $vb)
			echo "    |--$VB_SHORT_NAME  [$vb] (client)"  
			FOUND=1
		done
		fi
	    done
	    if [ $FOUND -eq 0 ] ; 
	    then 
		echo "    * avd is not registered as Testingmachine machine" ; 
		echo "    * to create a configuration file, try: --create-client-conf $AVD_NAME" ; 
	    fi
	done
    else
	echo "   no virtualbox machines currently running"
    fi
}

list_running_clients()
{
    echo "Running clients:"
    list_running_vbox 
    list_running_android
}


list_running_machines()
{
    echo "Running machines:"
    list_running_vbox_machines 
    list_running_android_machines
}


start_vbox_headless()
{
    if [ $(vboxmanage list vms | grep "$VM_NAME" | wc -l) -eq 0 ]
	then
	debug "Could not find vbox image: $VM_NAME"
	return 1
    fi
    debug "start_vbox_headless()"
    debug "start_vbox_headless: vboxheadless -s  \"$VM_NAME\""
    ERR_FILE=$$.vbm-err
    rm -f $ERR_FILE
    vboxheadless -s  "$VM_NAME"  2> $ERR_FILE  >/dev/null  &

    sleep 5
    ERROR_FOUND=$(grep -i -e "error" $ERR_FILE  | wc -l)

    if [ "$ERROR_FOUND" != "0" ]
    then   
	debug "Could not start vbox (headless). Error message:"
	debug "$(cat $ERR_FILE)"
	rm -f $ERR_FILE
	return 1
    fi

    rm -f $ERR_FILE

    return 0
}

set_qemu_program()
{
    WANTED_CPU=$1
    export QEMU_BINARY
    case $WANTED_CPU in
	"arm")
	    QEMU_BINARY=qemu-system-arm
	    ;;
	*)
	    echo "Unsupported cmou $WANTED_CPU"
	    ;;
    esac
    

}

start_qemu()
{
    VM_NAME="$1"

    set_qemu_program $QEMU_CPU

    debug "Starting qemu $1"
    debug "  $VM_START_ARGS"
    MONITOR_ARGS="-monitor unix:/tmp/qemu-$VM_NAME.sock,server,nowait "
    REDIR_ARGS="-redir tcp:$SSH_PORT::22 "
    EXTRA_ARGS="-no-reboot   -nographic -display none "
    
    START_VM="$QEMU_BINARY  -M versatilepb -m 256"
    START_VM="$START_VM  -kernel $QEMU_KERNEL  -hda $QEMU_HDA"
    START_VM="$START_VM  -append \"root=/dev/sda1\" "
    START_VM="$START_VM -initrd $QEMU_INITRD"
    START_VM="$START_VM  $MONITOR_ARGS $REDIR_ARGS $EXTRA_ARGS"

    if [ ! -f $QEMU_KERNEL ] || [ ! -f $QEMU_INITRD ] || [ ! -f $QEMU_HDA ] 
	then
	debug "Can't find either of:"
	debug "  kernel: $QEMU_KERNEL"
        debug "  initrd: $QEMU_INITRD"
	debug "  hda:    $QEMU_HDA"
	return 1
    fi


    if [ "$VNC_PORT" != "" ]
    then
	START_VM="$START_VM  -vnc :$VNC_PORT"
    fi
    debug "  $START_VM"	     
    echo "$START_VM" | bash & 
    
    return 0
# /dev/null
}

maximise_vbox()
{
    VN_NAME=$1

    debug "Will try to maximise VirtualBox window"
    CTR=0
    WIN_ID=""

    export WMCTRL=$(which wmctrl)

    if [ "$WMCTRL" = "" ]
    then   	
	echo "Command wmctrl missing on host"
	echo "Cannot maximise the window"
	debug "Command wmctrl missing on host"
	debug "Cannot maximise the window"
	return 1
    fi     

    while [ "$WIN_ID" = "" ]
    do
	debug "Waiting for VirtualBox window to appear"
	countdowner 5
	WIN_ID=$($WMCTRL -l | grep VirtualBox | grep -v Manager | grep $VM_NAME | awk ' { print $1}')
	CTR=$(( $CTR + 1))
	debug "     current id:$WIN_ID"
	if [ $CTR -gt 10 ]
	then
	    debug "    We've been waiting long enough"
	    RET=1
	    break
	fi
    done
    
    if [ "$WIN_ID" != "" ]
    then
	debug "Maximising window: $WIN_ID"
	sleep 2
	$WMCTRL -i -r $WIN_ID -b add,maximized_vert,maximized_horz
	RET=$?
    fi

    return $RET
}



start_vbox()
{
    export PROC_EXPR=$1
    debug "Start vbox: $VM_NAME"

    if [ $(vboxmanage list vms | grep -c "$PROC_EXPR" | wc -l) -eq 0 ]
	then
	debug "Could not find vbox image: $PROC_EXPR"
	return 1
    fi
    ERR_FILE=$$.vbm-out
    rm -f $ERR_FILE
    VBoxManage startvm "$VM_NAME"  2> $ERR_FILE  >/dev/null &

    sleep 3
    ERROR_FOUND=$(grep -e "error" $ERR_FILE  | grep -e "exit code" | wc -l)
    if [ "$ERROR_FOUND" != "0" ]
    then   
	debug "Could not start vbox. Error message:"
	debug "$(cat $ERR_FILE)"
	rm -f $ERR_FILE
	return 1
    fi

    rm -f $ERR_FILE
    maximise_vbox "$VM_NAME"
    return 0
}

start_android()
{
    export PROC_EXPR=$1
    debug "Start android: $VM_NAME"

    check_android_settings hard
    if [ "$?" != "0" ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	return 1
    fi 

    if [ ! -x $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	echo "Could not find $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS"
	return 1
    fi

    $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS -avd $PROC_EXPR  -netspeed full -netdelay none &
}

start_android_headless()
{
    export PROC_EXPR=$1
    debug "Start android in headless mode: $VM_NAME"

    check_android_settings hard
    if [ "$?" != "0" ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	return 1
    fi 

    if [ ! -x $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	echo "Could not find $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS"
	return 1
    fi

    $ANDROID_ADT_PATH/sdk/tools/$ANDROID_SYS -avd $PROC_EXPR  -netspeed full -netdelay none -no-window &
}


kill_vb_proc()
{
    VB_NAME="$1"
    KILL_ARG=$2

    debug "Kill vb proc $1 ($KILL_ARG)"

    sleep 5
    VBID=$(ps auxww | grep -i virtualbox | grep -v grep | grep $VB_NAME | awk ' { print $2 }')
    if [ "$VBID" != "" ]
	then
	debug "Still a vbox id to slay.. kill $KILL_ARG $VBID"
	kill $VBID 2>/dev/null
    fi
}

kill_android()
{
    VB_NAME=$1
    VB_NAME=$(grep VM_NAME $i | sed -e 's,VM_NAME=,,g' -e 's,\",,g' )
    if [ "$VB_NAME" != "" ]
    then
	kill_vb_proc "$VB_NAME"
	kill_vb_proc "$VB_NAME" "-9"
    fi
}

kill_vbox()
{
    VB_NAME=$1
    VB_NAME=$(grep VM_NAME $i | sed -e 's,VM_NAME=,,g' -e 's,\",,g' )
    if [ "$VB_NAME" != "" ]
    then
	kill_vb_proc "$VB_NAME"
	kill_vb_proc "$VB_NAME" "-9"
    fi
}

stop_vbox()
{
    VB_NAME=$1
    debug "Stopping vbox $VM_NAME"


    if [ "$VB_NAME" != "" ]
    then


                #
                #  Press ACPI powerbutton off
                #
	is_client_up $VM_NAME
	RET=$?
	if [ "$RET" = "0" ]
	then
	    return
	fi

	debug "  sending  acpipowerbutton off to $VB_NAME"
	VBoxManage controlvm $VB_NAME acpipowerbutton off 2>/dev/null
	wait_until_down $VB_NAME
	
	
                #
                #  Do a "hard" poweroff
                #
	is_client_up $VM_NAME
	RET=$?
	if [ "$RET" = "0" ]
	then
	    return
	fi

	debug "  sending  poweroff to $VB_NAME"
	VBoxManage controlvm $VB_NAME poweroff 2>/dev/null
	wait_until_down $VB_NAME
    fi
}


stop_qemu()
{
    VB_NAME=$1
    debug "Stopping qemu $VM_NAME"

    if [ "$VB_NAME" != "" ]
    then
	debug "Send to QEMU $VB_NAME: ctrl-alt-delete"
	send_to_qemu $VB_NAME "sendkey ctrl-alt-delete"
	wait_for_state down 20 $VB_NAME

	is_qemu_up $VB_NAME 
	RET=$?
	if [ "$RET" != "0" ]
	then
	    debug "    client is up, returning"
	    return
	fi

	debug "Send to QEMU $VB_NAME: system_powerdown"
	send_to_qemu $VB_NAME "system_powerdown"
	wait_for_state down 20  $VB_NAME

	is_qemu_up $VB_NAME 
	RET=$?
	if [ "$RET" != "0" ]
	then
	    debug "    client is up, returning"
	    return
	fi

	debug "Send to QEMU $VB_NAME: quit"
	send_to_qemu $VB_NAME "quit"
	wait_for_state down 20 $VB_NAME

	break
    fi	
}



stop_android()
{
    VB_NAME=$1
    debug "Stopping Android $VM_NAME"

    check_android_settings hard
    if [ "$?" != "0" ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	return 1
    fi 

    if [ ! -x $ADB ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	echo "Could not find adb"
	return 1
    fi



    if [ "$VB_NAME" != "" ]
    then
	debug "Killing Android $VB_NAME"
	$ADB  -s emulator-$ANDROID_PORT emu kill  >/dev/null 2>/dev/null
	
	wait_for_state down 20 $VB_NAME

	is_android_up $VB_NAME 
	RET=$?
	if [ "$RET" != "0" ]
	then
	    debug "    client is up, returning"
	    return
	fi


	break
    fi	
}


check_qemu_proc()
{
    PROC_EXPR=$1
    RET=$(ps auxww | grep qemu | grep -c $PROC_EXPR )

    debug "Number of qemu processes: $RET"
    
    return $RET
}

check_android_proc()
{
    PROC_EXPR=$1
    RET=$(ps auxww | grep emulator | grep -c $PROC_EXPR )

    debug "Number of Android processes: $RET"
    
    return $RET
}

check_vbox_proc()
{
    PROC_EXPR=$1
    RET=$(ps -u hesa awww | grep -i virtualbox | grep -c $PROC_EXPR )

    debug "Number of vbox processes: $RET"
    
    return $RET
}

stop_helper()
{
    WANTED_VM=$1
    VM_TYPE=$2
    CLI_CONF=$3


    debug "stop_helper: $VM_NAME"
    debug "Reading client conf $CLI_CONF"
    .  $CLI_CONF

    is_client_ssh_up
    RET=$?
    if [ "$RET" != "0" ]
    then
	debug "Host $1 ssh seems down, no use stopping it via ssh. Continuing with closing the vm"
    fi

    if [ "$VM_SUPERUSER" != "" ] && [ "$SSH_SHUTDOWN_COMMAND" != "" ] 
    then
	is_client_ssh_up
	RET=$?
	if [ "$RET" = "0" ]
	then
	    debug "Super user account available"
	    debug "  trying to stop via ssh"
	    $SSH $SSH_TEST_OPTIONS  -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $SSH_SHUTDOWN_COMMAND
	    RET=$?
	fi
	
	if [ "$RET" != "0" ]
	then
	    debug "Failed stopping client with ssh"
	    debug "   Command: $SSH $SSH_TEST_OPTIONS  -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $SSH_SHUTDOWN_COMMAND"
	else
	    wait_until_down $WANTED_VM
	fi
    fi
    
    debug "Stop $1 using virtual machine ($VM_TYPE)"

    case $VM_TYPE in
	"VirtualBox")
	    debug "Stoping vbox $1"
	    stop_vbox $1
	    kill_vbox $1


	    check_vbox_proc $1
	    RET=$?
	    log "$RET" "Stop VirtualBox" "$VM_NAME"
	    return $RET
	    ;;

	"qemu")
	    debug "Stoping qemu $WANTED_VM"
	    stop_qemu "$WANTED_VM"

	    check_qemu_proc $1
	    RET=$?
	    log "$RET" "Stop qemu" "$VM_NAME"
	    return $RET
	    ;;

	"Android")
	    debug "Stoping Android $WANTED_VM"
	    stop_android "$WANTED_VM"

	    check_android_proc $1
	    RET=$?
	    log "$RET" "Stop Androd" "$VM_NAME"
	    return $RET
	    ;;

	*)
	    echo "Failed finding vm type for $1"
	    exit 123
	    ;;
    esac
}


pause_helper()
{
    WANTED_VM=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "pause_helper: $VM_NAME"
    debug "Reading client conf $CLI_CONF"
    .  $CLI_CONF

    debug "Pause $1 using virtual machine ($VM_TYPE)"

    case $VM_TYPE in
	"VirtualBox")
	    debug "Pausing vbox $1"
	    VBoxManage controlvm $VM_NAME pause 
#sleep 10 ; VBoxManage controlvm Ubuntu-12.04 pause ; sleep 600 ; VBoxManage controlvm Ubuntu-12.04 resume ; ssh -p 9022  root@localhost ntpdate-debian	    kill_vbox $1
	    ;;

	"Android")
            echo "Can't pause Android yet!"
	    return 1
	    ;;

	"qemu")
            echo "Can't pause qemus yet!"
	    return 1
	    ;;

	*)
	    echo "Failed finding vm type for $1"
	    exit 123
	    ;;
    esac
}

resume_helper()
{
    WANTED_VM=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "resume_helper: $VM_NAME"
    debug "Reading client conf $CLI_CONF"
    .  $CLI_CONF

    debug "Resume $1 using virtual machine ($VM_TYPE)"

    case $VM_TYPE in
	"VirtualBox")
	    debug "Resuming vbox $1"
	    VBoxManage controlvm $VM_NAME resume
	    printf "\n\n\t*****RESET TIME LATER!!!!\n\n\n"
#sleep 10 ; VBoxManage controlvm Ubuntu-12.04 pause ; sleep 600 ; VBoxManage controlvm Ubuntu-12.04 resume ; ssh -p 9022  root@localhost ntpdate-debian	    kill_vbox $1
	    ;;

	"qemu")
            echo "Can't pause qemus yet!"
	    return 1
	    ;;

	*)
	    echo "Failed finding vm type for $1"
	    exit 123
	    ;;
    esac
}

stop_machine()
{
    CLIENT_FOUND=false
    WANTED_VM=$1

    debug "stop_machine $*"

    get_info_for_machine $1

    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    else
	debug "stop_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF)"
	stop_helper $WANTED_VM $VM_TYPE $CLI_CONF
	return $?
    fi

    return 1
}



stop_client()
{
    CLIENT_FOUND=false
    WANTED_VM=$1
    START_ARGS=$2

    get_info_for_client $1
#    CLIENT_FOUND=$?

    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
    else
	debug "stop_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF)"
	stop_helper $WANTED_VM $VM_TYPE $CLI_CONF
	return $?
    fi

    return 1
}


pause_machine()
{
    CLIENT_FOUND=false
    WANTED_VM=$1

    debug "pause_machine $*"

    get_info_for_machine $1

    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    else
	debug "pause_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF)"
	pause_helper $WANTED_VM $VM_TYPE $CLI_CONF
	return $?
    fi

    return 1
}



pause_client()
{
    CLIENT_FOUND=false
    WANTED_VM=$1
    START_ARGS=$2

    get_info_for_client $1
    
    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
    else
	debug "pause_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF)"
	pause_helper $WANTED_VM $VM_TYPE $CLI_CONF
	return $?
    fi

    return 1
}

resume_machine()
{
    CLIENT_FOUND=false
    WANTED_VM=$1

    debug "resume_machine $*"

    get_info_for_machine $1

    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    else
	debug "resume_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF)"
	resume_helper $WANTED_VM $VM_TYPE $CLI_CONF
	return $?
    fi

    return 1
}



resume_client()
{
    CLIENT_FOUND=false
    WANTED_VM=$1
    START_ARGS=$2

    get_info_for_client $1
    
    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
    else
	debug "resume_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF)"
	resume_helper $WANTED_VM $VM_TYPE $CLI_CONF
	return $?
    fi

    return 1
}

find_vm_type()
{
    VM_NAME=$1
    
    VBOX_FOUND=$(vboxmanage list vms | awk ' BEGIN { FS="\""}  { print $2 } ' | sed 's,\",,g' | grep -w $VM_NAME | wc -l)

    ANDROID_FOUND=$(list_android_machines  | grep -w $VM_NAME | wc -l)

    debug "find_vm_type: VBOX_FOUND:    $VBOX_FOUND"
    debug "find_vm_type: ANDROID_FOUND: $ANDROID_FOUND"

    if [ $VBOX_FOUND -ne 0 ]
    then
	export VM_TYPE="VirtualBox"
    elif [ $ANDROID_FOUND -ne 0 ]
    then
	export VM_TYPE="Android"
    fi
}


start_helper()
{
    debug "start_helper: $*"

    WANTED_NAME=$1
    VM_TYPE=$2
    CLI_CONF=$3
    START_ARGS=$4

    debug "Reading client conf $CLI_CONF"
    .  $CLI_CONF

    case $VM_TYPE in
	"VirtualBox")
	    debug "Starting vbox $1 ($START_ARGS)"
	    if [ "$START_ARGS" = "headless"  ]
	    then
		start_vbox_headless $VM_NAME
		RET=$?
	    else
		start_vbox $VM_NAME
		RET=$?
	    fi

	    if [ $RET -ne 0 ]
		then
		debug "Failed to start: $VM_NAME"
		echo "Failed to start: $VM_NAME"
		return 1
	    fi


	    check_vbox_proc $VM_NAME
	    RET=$?
	    
	    if [ $RET -ne 0 ]
		then
		OK=0
	    else
		OK=1
	    fi

	    OK=$?
	    log "$OK" "Start VirtualBox" "$VM_NAME"
	    ;;
	"Android")
	    debug "Starting android $1 ($START_ARGS)"
	    if [ "$START_ARGS" = "headless"  ]
	    then
		start_android_headless $VM_NAME
		sleep 2
	    else
		start_android $VM_NAME
		sleep 2
	    fi

		
	    ;;
	"qemu")
	    debug "Starting qemu $1"
	    start_qemu "$WANTED_NAME" "&"

	    check_qemu_proc $VM_NAME
	    RET=$?
	    
	    if [ $RET -ne 0 ]
		then
		OK=0
	    else
		OK=1
	    fi

	    OK=$?
	    log "$OK" "Start qemu" "$VM_NAME"
	    ;;
	*)
	    echo "Failed finding vm type for $1"
	    log "1" "Unknown vm type" "$VM_NAME"
	    exit
	    ;;
    esac
    


    if [ "$2" = "--no-wait" ]
    then
	return 0
    fi
    
    wait_until_up $VM_NAME


}


start_machine()
{
    CLIENT_FOUND=false
    WANTED_VM=$1
    START_ARGS="$2"

    get_info_for_machine $1

    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    else
	start_helper "$WANTED_VM" $VM_TYPE $CLI_CONF $START_ARGS
    fi
}


start_client()
{
    CLIENT_FOUND=false
    WANTED_VM="$1"
    START_ARGS="$2"

    debug "start_client: $*"

    get_info_for_client $1
#    CLIENT_FOUND=$?

    
    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
    else
        debug "start_client: calling 	start_helper ($WANTED_VM, $VM_TYPE, $CLI_CONF, $START_ARGS)"
	start_helper "$WANTED_VM" "$VM_TYPE" "$CLI_CONF" "$START_ARGS"
    fi

    return 
}

start_client_wait_for_ssh()
{
    auto_debug "Starting client $CLIENT_NAME"
    $VMM_CLIENT --start-client $CLIENT_NAME
    
    auto_debug "Wait for ssh"
    $VMM_CLIENT --wait-for-ssh $CLIENT_NAME 300
    RET=$?

    return $RET
}


is_qemu_up()
{
    export WANTED_VM=$1

    CNT=$(send_to_qemu $WANTED_VM "info status" | grep "VM status: running" | wc -l)

    debug "    is_qemu_up: $CNT"

    # If the VM is running (>1), return 0
    if [ $CNT -ne 0 ]
    then
	debug "qemu vm ($WANTED_VM) is running"
	return 0
    fi

    debug "qemu vm ($WANTED_VM) is NOT running"
    return 1
}

is_vbox_up()
{
    export WANTED_VM=$1

    debug "    is_vbox_up? "

    CNT=$(vboxmanage list runningvms | awk 'BEGIN { FS="\""}  { print $2 } ' | sed 's,\",,g' | grep $WANTED_VM | wc -l)
    
    debug "    is_vbox_up: $CNT"

    # If the VM is running (>1), return 0
    if [ $CNT -ne 0 ]
    then
	debug "vbox vm ($WANTED_VM) is running"
	return 0
    fi

    debug "vbox vm ($WANTED_VM) is NOT running"
    return 1
}

is_android_up()
{
    export WANTED_VM=$1


    check_android_settings hard
    if [ "$?" != "0" ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	return 1
    fi 

    if [ ! -x $ADB ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	echo "Could not find adb"
	return 1
    fi


    debug "    get_info_for_client $1"
    get_info_for_client "$1"

    if [ "$ANDROID_PORT" = "" ] ; 
    then 
	sleep 3
	get_info_for_client "$1"
    fi

    debug "    is_android_up? adb  -s emulator-$ANDROID_PORT shell ls"
    $ADB  -s emulator-$ANDROID_PORT shell ls >/dev/null 2>/dev/null
    RET=$?
    
    debug "    is_android_up: $CNT"

    # If the VM is NOT running (!=0), return 1
    if [ $RET -ne 0 ]
    then
	debug "android avd ($WANTED_VM) is NOT running"
	return 1
    fi

    debug "android avd ($WANTED_VM) is running"
    return 0
}


is_client_up()
{
    WANTED_VM=$1

    if  [ "$VM_TYPE" = "" ]
    then
	get_info_for_client $1
    fi

    case $VM_TYPE in
	"VirtualBox")
	    is_vbox_up $1
	    RET=$?
	    ;;

	"Android")
	    is_android_up $1
	    RET=$?
	    ;;

	"qemu")
	    is_qemu_up $1
	    RET=$?
	    ;;

	*)
	    echo "Failed finding vm type for $1"
	    exit 123
	    ;;
    esac
    
    debug "is_client_up ($WANTED_VM, $VM_TYPE)  => $RET"
    return $RET
}

is_client_ssh_up()
{
    debug "Check if Client ssh server is up"
    debug "   ssh:     $SSH"
    debug "   options: $SSH_TEST_OPTIONS"
    debug "   port:    -p $SSH_PORT"
    debug "   user     $VM_USER@$VM_IP_ADDRESS"
    debug "   command: exit"
    $SSH $SSH_TEST_OPTIONS \
        -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS exit \
         2>/dev/null
    RET=$?
    debug "  Returning: $RET"
    return $RET
}

is_client_x11_up()
{
    WANTED_VM=$1

    CLIENT_FOUND=false
    WANTED_VM=$1

    get_info_for_client $1

    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
	return 120
    fi

    case $VM_TYPE in
	"VirtualBox")
	    debug "Check if Client X11 is up"
	    exec_client_command $1 "DISPLAY=:0 xdpyinfo 2>/dev/null >/dev/null 2>/dev/null "
	    RET=$?
	    ;;
	"qemu")
	    echo "Can't check X11 on qemu"
	    debug "Can't check X11 on qemu"
	    RET=1
	    ;;
	"Android")
	    echo "Can't check X11 on Android"
	    debug "Can't check X11 on Android"
	    RET=1
	    ;;
	*)
	    debug "  Unknown vm type"
	    echo "Failed finding vm type for $1"
	    RET=1
	    ;;
    esac


    debug "is_client_x11_up  Returning: $RET"
    return $RET
}

#    Can be used with other VM's that require Internet access

is_client_online()
{
    CLIENT_FOUND=false

    get_info_for_client $1
#    CLIENT_FOUND=$?
    RET=1

    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
	return 120
    fi

    echo "Check if Client is online"
    debug "   ssh:     $SSH"
    debug "   options: $SSH_TEST_OPTIONS"
    debug "   port:    -p $SSH_PORT"
    debug "   user     $VM_USER@$VM_IP_ADDRESS"
    debug "   command: ping -c1 www.google.com"

    $SSH $SSH_TEST_OPTIONS \
        -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS ping -c1 www.google.com \
        > /dev/null

    RET=$?
    debug "  Returning: $RET\n"
    ## printf probably a little silly here
    printf "  Google can be reached...\n"
    return $RET

}

#    eGov specific, is service actually online, if not abort...
#is_egovonline()
#{
#    if ping -c1 account.egov.bz.it > /dev/null
#      then echo "eGov online..."
#    else
#      echo "Abort, server nor reachable"
#    fi
#}

wait_for_state()
{
    EXPECTED_STATE="$1"
    TIMEOUT=$2
    VB_NAME=$3

    debug "Will wait (vm:$VB_NAME) for $1 for $2 seconds"
    
    TIMEDOUT=false
    START_SECS=$(date "+%s")
    # Set to a negative integer value
    DIFF=-12

    while [ "$TIMEDOUT" = "false" ]
    do
	BREAK=false

	debug "    Check if client is up: "

	is_client_up $VB_NAME
	RET=$?

	if [ "$EXPECTED_STATE" = "up" ]
	then
	    if [ "$RET" = "0" ]
	    then
		BREAK=true
	    fi
	else
	    if [ "$RET" != "0" ]
	    then
		BREAK=true
	    fi
	fi

	debug "   Should we break? $BREAK  "

	if [ "$BREAK" = "true" ]
	then
	    break
	fi

	sleep 10
	CURRENT=$(date "+%s")
	DIFF=$(( $START_SECS + $TIMEOUT - $CURRENT))
	debug "  Started: $START_SECS  Current: $CURRENT Timeout:  $TIMEOUT"
	debug "  Diff:    $DIFF"

	if [ $DIFF -le 0 ]
	then
	    TIMEDOUT=true
	fi
	debug "   have we timed out?   $TIMEDOUT "
    done
    debug "timeout or state reached ... continuing"
}


wait_for_ssh()
{
    EXPECTED_STATE="$1"
    TIMEOUT=$2
    CLIENT=$3

    if [ "$CLIENT" != "" ]
    then
	get_info_for_client $CLIENT
    fi

    debug "Will wait for (ssh) $1 for $2 seconds"
    
    TIMEDOUT=false
    START_SECS=$(date "+%s")
    # Set to a negative integer value
    DIFF=-12

    while [ "$TIMEDOUT" = "false" ]
    do
	BREAK=false

	debug "    Check if client is up: "

	is_client_ssh_up
	RET=$?

	if [ "$EXPECTED_STATE" = "up" ]
	then
	    if [ "$RET" = "0" ]
	    then
		BREAK=true
	    fi
	else
	    if [ "$RET" != "0" ]
	    then
		BREAK=true
	    fi
	fi

	debug "   Should we break? $BREAK  "

	if [ "$BREAK" = "true" ]
	then
	    break
	fi

	sleep 10
	CURRENT=$(date "+%s")
	DIFF=$(( $START_SECS + $TIMEOUT - $CURRENT))
	debug "  Started: $START_SECS  Current: $CURRENT Timeout:  $TIMEOUT"
	debug "  Diff:    $DIFF"

	if [ $DIFF -le 0 ]
	then
	    TIMEDOUT=true
	fi
	debug "   have we timed out?   $TIMEDOUT "
    done
    debug "timeout or state reached ... continuing"
}


wait_until_up()
{
    wait_for_state up $VM_STARTUP_TIMEOUT $1
}

wait_until_down()
{
    wait_for_state down $VM_STOP_TIMEOUT $1
}


check_ssh_helper()
{
    VM_NAME=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "Check ssh of $VM_NAME"

    get_info_for_client $1
    
#echo     $SSH $SSH_TEST_OPTIONS  -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS 
    $SSH $SSH_TEST_OPTIONS  -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS exit \
	2>/dev/null >/dev/null
    RET=$?
    
    if [ $RET -ne 0 ]
    then
	echo "not available"
	debug "   $VM_NAME down or not responding"
    else	     
	debug "   $VM_NAME is ok"
	echo "ok"
    fi


    return $RET
}


send_to_qemu()
{
    WANTED_VM=$1
    MSG=$2
    echo "$MSG" | socat - unix-connect:/tmp/qemu-${WANTED_VM}.sock 2>/dev/null | \
          grep -v "(qemu)" | grep -v "QEMU [0-9\. ]*monitor"
}

check_status_helper()
{
    WANTED_VM=$1
    VM_TYPE=$2
    CLI_CONF=$3

    debug "Check status of $WANTED_VM"

    CLI_CONF=$i
    debug "Reading client conf $CLI_CONF"
    .  $CLI_CONF
    

    case $VM_TYPE in
	"VirtualBox")
	    debug "  check status with vbox"
	    is_vbox_up "$VM_NAME"
	    RET=$?
	    debug "  status: $RET"
	    return $RET
	    ;;
	"qemu")
	    debug "  check status with qemu"
	    send_to_qemu "$WANTED_VM" "info status" > /dev/null
	    RET=$?
	    debug "  status: $RET"
	    return $RET
	    ;;
	*)
	    debug "  Unknown vm type"
	    echo "Failed finding vm type for $1"
	    exit 123
	    ;;
    esac

    return $RET
}

check_client_ssh()
{
    CLIENT_FOUND=false
    WANTED_VM=$1

    get_info_for_client $1
#    CLIENT_FOUND=$?

    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
	return 120
    else
	echo -n "Client \"$WANTED_VM\" ssh connection: "
	debug "Check ssh connection for $WANTED_VM"
	check_ssh_helper $WANTED_VM $VM_TYPE $CLI_CONF
	RET=$?
	debug "  status: $RET"
	return $RET
	return $?
    fi
}

check_client_status()
{
    CLIENT_FOUND=false
    WANTED_VM="$1"

    debug "Checking status of $1"

    get_info_for_client $1
#    CLIENT_FOUND=$?

    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
	return 120
    else
	echo -n "Client \"$WANTED_VM\" status: "
	check_status_helper "$WANTED_VM" "$VM_TYPE" "$CLI_CONF"
	RET=$?
	if [ "$RET" = "0" ]
	then
	    echo "running"
	    return 0
	fi
	echo "not running"

	return $RET
    fi
}

print_client()
{
    WANTED_VM=$1

    for d in $ETC_DIRS
    do
	for i in $(find $d/clients -name "$1.conf" 2>/dev/null)
	do
	    CLI_CONF=$i
	    echo "Configuration file: $CLI_CONF"
	    cat $CLI_CONF
	done
    done
}




exec_client_command()
{
    CLIENT_FOUND=false
    WANTED_VM=$1
    COMMAND="$2"
    ON_FAIL="$3"

    debug "exec_client_command $1 $2"

    get_info_for_client $1
#    CLIENT_FOUND=$?
    RET=1

    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
	return 120
    fi

    if [ "$VM_TYPE" = "VirtualBox" ]
    then
	debug "$SSH -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS $COMMAND"
	$SSH -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS \
	    "$COMMAND"
	RET=$?
    elif [ "$VM_TYPE" = "Android" ]
    then
	exec_client_command_android $ANDROID_PORT "$COMMAND"
	RET=$?
    else
	echo "exec_client_command(): support for \"$VM_NAME\" not implemented yet!"
	RET=1
    fi
    
    
	
    return $RET
}

exec_client_command_as_root()
{
    CLIENT_FOUND=false
    WANTED_VM=$1
    COMMAND="$2"

    debug "exec_client_command $1 $2"

    get_info_for_client $1
#    CLIENT_FOUND=$?

    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found for: $1"
	return 120
    else
	debug "$SSH -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS $COMMAND"
	$SSH -p $SSH_PORT $VM_SUPERUSER@$VM_IP_ADDRESS \
	    "$COMMAND"
	return $?
    fi
}

check_machine()
{
    CLIENT_FOUND=false
    WANTED_VM=$1

    get_info_for_machine $1

    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    else
	echo -n "Machine "
	check_helper $VM_NAME $VM_TYPE $CLI_CONF
    fi
}

get_vbox_specific_info()
{
#	echo find ssh port
#	echo	vboxmanage   showvminfo $VM_NAME 
    if [ "$SSH_PORT" = "auto" ]
    then
	SSH_PORT=$(vboxmanage   showvminfo $VM_NAME 2>/dev/null | grep "NIC" | grep -e Rule -e ssh | grep 22 | grep "host port" | sed 's,[a-zA-Z0-9,: \ =()]*host port[ \t]*=,,g' | awk '{print $1}' | sed 's/,//g' )
    fi

    if [ "$SSH_PORT" = "" ]
    then
	return 1
    fi

#    echo "SSH_PORT=$SSH_PORT"
    return 0
}

get_android_specific_info()
{
    MY_VM="$1"

    ANDROID_SYS=$( grep ANDROID_SYS $CLI_CONF | sed 's,ANDROID_SYS=,,g' | sed 's,\",,g')
    ANDROID_PORT=$(get_avd_port_for_name $MY_VM )

}

get_vm_specific_info()
{
    MY_VM="$1"
    RET=0
    if [ "$VM_TYPE" = "VirtualBox" ]
    then
	get_vbox_specific_info
    elif [ "$VM_TYPE" = "Android" ]
    then
	
	get_android_specific_info $MY_VM
    else
	echo "get_vm_specific_info(): support for \"$VM_NAME\" not implemented yet!"
    fi
    
    return $RET
}


get_info_for_client()
{
    debug "Trying to get info for client: $1"
    CLIENT_FOUND=false

    for d in $ETC_DIRS
    do
	TMP_CLIENTS=$(find $d/clients -name "$1.conf" 2>/dev/null)
	for i in $TMP_CLIENTS
	do
	    
	    export VM_NAME=$(grep VM_NAME $i | sed -e 's,VM_NAME=,,g' -e 's,\",,g' )
	    
	    CLI_CONF=$i
	    VM_TYPE=$(grep VM_TYPE $i | sed -e 's,VM_TYPE=,,g' -e 's,\",,g' )

	    . $CLI_CONF

	    CLIENT_FOUND=true

	    get_vm_specific_info $VM_NAME
	    RET=$?
	    
	    if [ $RET -ne 0 ] ; then debug "Client seems to be down"; CLIENT_FOUND=false; fi
	done
	if [ "$CLIENT_FOUND" = "true" ]
	then
	    debug "  got info for $1: $VM_NAME, $VM_TYPE, $CLI_CONF"
	    return 0
	fi
    done

    debug "  got no info for $1"
    return 1
}


get_info_for_machine()
{
    CLIENT_FOUND=false
    WANTED_VM=$1

    debug "Trying to get info for machine: $1"

    for d in $ETC_DIRS
    do
	debug "  dir:  $d"
	for i in $(find $d/clients -name "*.conf" 2>/dev/null)
	do
	    debug "     f:  $i"
	    
	    export VM_NAME=$(grep VM_NAME $i | sed -e 's,VM_NAME=,,g' -e 's,\",,g' )
	    debug "        wanted: $WANTED_VM "
	    debug "        found:  $VM_NAME"
	    if [ "$VM_NAME" = "$WANTED_VM" ]
	    then
		CLI_CONF=$i
		VM_TYPE=$(grep VM_TYPE $i | sed -e 's,VM_TYPE=,,g' -e 's,\",,g' )
		CLIENT_FOUND=true
		get_vm_specific_info
	    fi
	done
	if [ "$CLIENT_FOUND" = "true" ]
	then
	    debug "  got info for $1: $VM_NAME, $VM_TYPE, $CLI_CONF"
	    return 0
	fi
    done

    debug "  got no info for $1"
    return 1
}


vnc_snapshot()
{
    rm -f tmp.jpg 
   vncsnapshot :5 tmp.jpg 
}



vbox_snapshot()
{
    
    VBoxManage controlvm $1 screenshotpng "$2"
}

android_snapshot()
{
    check_android_settings hard
    if [ "$?" != "0" ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	return 1
    fi 

    if [ ! -x $ADB ] ; then
	echo "Android commands doesn't seem to be set up correctly."
	echo "Could not find adb"
	return 1
    fi


    # COmmand line fron http://blog.shvetsov.com/2013/02/grab-android-screenshot-to-computer-via.html
    $ADB  -s emulator-$1 shell screencap -p | perl -pe 's/\x0D\x0A/\x0A/g' > $2
}

rename_screenshot_name()
{
    export IMG=$1
    LAST_PIC=$(ls -1t Screenshot-$1-*.jpg | head -1)

    LAST_NR=$(echo $LAST_PIC | sed -e "s,Screenshot-$IMG\-,,g" -e "s,.jpg,,g")

    NEXT_NR=$(( $LAST_NR + 1 ))
    NEXT_NR_STR=$(printf "%.3d" $NEXT_NR)
    
    NEXT_IMG=Screenshot-$1-$NEXT_NR_STR.jpg

    mv tmp.jpg $NEXT_IMG
    
}

client_screenshot()
{
    init_vmm

    debug "client_screenshot $1"

    get_info_for_client "$1"

    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    fi
    
    if [ ! -d $TM_IMAGE_DIR ] ; then mkdir -p $TM_IMAGE_DIR ; fi
    PIC_NAME=$TM_IMAGE_DIR/image-$VM_NAME-`date +%s`.png

    case $VM_TYPE in
	"VirtualBox")
	    vbox_snapshot $VM_NAME $PIC_NAME
	    echo "VBOX screenshots not implemented"
	    ;;
	"qemu")
	    vnc_snapshot > /dev/null 2> /dev/null
	    ;;
	
	"Android")
	    android_snapshot "$ANDROID_PORT" "$PIC_NAME"
# > /dev/null 2> /dev/null
	    ;;
	
	*)
	    echo "Screenshots not implemented for $1"
	    ;;
    esac

    if [ -f tmp.jpg ]
    then
	rename_screenshot_name $1
	echo "Stored: \"$NEXT_IMG\""
    else
	echo "Uh oh"
    fi
}


auto_debug()
{
    debug "[$VMM_AUTO_NAME] $*"
}



exec_user_scripts()
{
    TMP=0
    export script=bogus
    while [ "$script" != "" ]
    do
	
 	LINE=${SCRIPTS_TO_EXECUTE[$TMP]}
	if [ "$LINE" = "" ] ; then break ; fi
	auto_debug "Executing user supplied script: $script"
	
	TYPE=${LINE:0:9}
	script=${LINE:9}
	
	if [ "$TYPE" = "rem-user:" ]
	then
	    echo ${VMM_CLIENT} --client-exec ${CLIENT_NAME} "\"${script}\"" | bash
	elif [ "$TYPE" = "rem-root:" ]
	then
	    echo ${VMM_CLIENT} --client-exec-as-root ${CLIENT_NAME} "\"${script}\"" | bash
	else
	    ${script}
	fi
	
	RET=$?
	auto_debug "User supplied script ($script)returned:  $RET"
	
	if [ $RET -ne 0 ]
	then
	    return $RET
	fi
	
	TMP=$(( $TMP + 1 ))
    done



    return 0
}



open_ssh()
{
    get_info_for_client $1
    
    $SSH $SSH_TEST_OPTIONS \
        -p $SSH_PORT $VM_USER@$VM_IP_ADDRESS 
	
    return $?
}



import_appliance()
{
    OVA_FILE=$1
    if [ ! -f $OVA_FILE ]
    then
	echo "Can't find the ova file $OVA_FILE"
	return 1
    fi

    VBoxManage import "$OVA_FILE" 

}

copy_from_host()
{
    MY_SRC_HOST=$1
    MY_SRC_LOC=$2
    MY_DST_LOC=$3

    get_info_for_client $MY_SRC_HOST
    
    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found or client is not running: $1"
	return 1
    fi

    case $VM_TYPE in
	"VirtualBox")
	    echo "copy vbox"
	    ;;
    
	"Android")

	    check_android_settings hard
	    if [ "$?" != "0" ] ; then
		echo "Android commands doesn't seem to be set up correctly."
		return 1
	    fi 
	    
	    if [ ! -x $ADB ] ; then
		echo "Android commands doesn't seem to be set up correctly."
		echo "Could not find adb"
		return 1
	    fi
	    debug "copy android"
	    debug "     adb  -s emulator-$ANDROID_PORT pull $MY_SRC_LOC $MY_DST_LOC"
	    $ADB  -s emulator-$ANDROID_PORT pull $MY_SRC_LOC $MY_DST_LOC
	    ;;
	*)
	    echo "copy not supported"
	    return 1
	    ;;

    esac
    
    return 0
} 


copy_to_host()
{
    MY_SRC_LOC=$1
    MY_DST_HOST=$2
    MY_DST_LOC=$3

    get_info_for_client $MY_DST_HOST
    
    if [ "$CLIENT_FOUND" = "false" ]
    then
	echo "No client configuration found or client is not running: $1"
	return 1
    fi

    case $VM_TYPE in
	"VirtualBox")	
	    debug "$SCP -r  $MY_SRC_LOC -P  $SSH_PORT $VM_USER@$VM_IP_ADDRESS:$MY_DST_LOC"
	    $SCP -r  -P  $SSH_PORT $MY_SRC_LOC $VM_USER@$VM_IP_ADDRESS:$MY_DST_LOC
	    ;;
    
	"Android")

	    check_android_settings hard
	    if [ "$?" != "0" ] ; then
		echo "Android commands doesn't seem to be set up correctly."
		return 1
	    fi 

	    if [ ! -x $ADB ] ; then
		echo "Android commands doesn't seem to be set up correctly."
		echo "Could not find adb"
		return 1
	    fi
	    debug "copy android"
	    debug "     adb  -s emulator-$ANDROID_PORT push $MY_SRC_LOC $MY_DST_LOC"
	    $ADB  -s emulator-$ANDROID_PORT push $MY_SRC_LOC $MY_DST_LOC
	    ;;
	*)
	    echo "copy not supported"
	    return 1
	    ;;

    esac
    
    return 0
} 


client_copy_file()
{
    MY_SRC="$1"
    MY_DST="$2"

    IFS=":"; declare -a MY_SRC_ARR=($MY_SRC) 
    SRC_HOST=${MY_SRC_ARR[0]}
    SRC_LOC=${MY_SRC_ARR[1]}
    if [ "$SRC_LOC" = "" ] ; then SRC_LOC=$SRC_HOST; SRC_HOST="" ; fi
    
    IFS=":"; declare -a MY_DST_ARR=($MY_DST) 
    DST_HOST=${MY_DST_ARR[0]}
    DST_LOC=${MY_DST_ARR[1]}
    if [ "$DST_LOC" = "" ] ; then DST_LOC=$DST_HOST; DST_HOST="" ; fi

    # Set IFS back to space :) .... otherwise things will start behave odd
    IFS=" "

    debug "Copy:"
    debug "  '$SRC_HOST' ::: $SRC_LOC"
    debug "  '$DST_HOST' ::: $DST_LOC"

    RET=1

    if [ "$SRC_HOST" != "" ] && [ "$DST_HOST" != "" ] 
    then
	echo "Currently tm-vmm does not support copying from one client to another"
    elif [ "$SRC_HOST" != "" ]
    then
	debug copy_from_host $SRC_HOST $SRC_LOC  $DST_LOC
	copy_from_host $SRC_HOST $SRC_LOC  $DST_LOC
	RET=$?
    elif [ "$DST_HOST" != "" ]
    then
	debug copy_to_host   $SRC_LOC  $DST_HOST $DST_LOC
	copy_to_host         $SRC_LOC  $DST_HOST $DST_LOC
	RET=$?
    else
	echo "uh oh"
    fi

    echo "RETURN $RET"

    return $RET
}


unlock_screen()
{
    CLIENT=$1
    get_info_for_client "$1"


    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    fi
    RET=0
    case $VM_TYPE in
	"VirtualBox")
	    echo "VBOX unlock screen"
	    RET=1
	    ;;
	"qemu")
	    echo "QEMU unlock screen"
	    RET=1
	    ;;
	
	"Android")
	    exec_client_command $CLIENT "input keyevent 82"
	    RET=$?
	    ;;
	
	*)
	    echo "Screenshots not implemented for $1"
	    RET=1
	    ;;
    esac
    
    return $RET
}

get_suffix_from_file()
{
    MY_FILE=$1
    debug "get_suffix_from_file() MY_FILE: $MY_FILE"

    MY_FILE_SHORT=$(basename "$MY_FILE")
    debug "get_suffix_from_file() MY_FILE_SHORT: $MY_FILE_SHOR"

    MY_FILE_PREFIX=${MY_FILE_SHORT%.*}
    debug "get_suffix_from_file() MY_FILE_PREFIX: $MY_FILE_PREFIX"

    MY_FILE_SUFFIX=${MY_FILE_SHORT##*.}
    debug "get_suffix_from_file() MY_FILE_SUFFIX: $MY_FILE_SUFFIX"

    echo $MY_FILE_SUFFIX
    
}

android_install_app()
{
    CLIENT=$1
    APP=$2
    MODE=$3

    get_info_for_client "$CLIENT"

    exec_client_raw_android "$ANDROID_PORT" "$MODE $APP"
}

vbox_install_app()
{
    CLIENT=$1
    APP=$2
    MODE=$3

    get_info_for_client "$CLIENT"

    APP_SUF=$(get_suffix_from_file "$APP")

    if [ "$MODE" = "uninstall" ]
    then
	exec_client_command_as_root $CLIENT "dpkg --remove $APP"
	RET=$?
	
    else

	case $APP_SUF in
	    "deb")
		
		copy_to_host                $APP  $CLIENT "/tmp"
		RET=$?
		if [ "$RET" != "0" ]; then return $RET; fi
		
		exec_client_command_as_root $CLIENT "dpkg --install /tmp/$(basename $APP)"
		RET=$?
		if [ "$RET" != "0" ]; then return $RET; fi
		
		exec_client_command_as_root $CLIENT "rm -f /tmp/$(basename $APP)"
		RET=$?
		
		;;
	    "rpm")
		echo "VBOX install rpm pkg: $APP"
		echo "VBOX install deb pkg: $APP"
		copy_to_host                $APP  $CLIENT "/tmp"
		exec_client_command_as_root $CLIENT "rpm --install /tmp/$(basename $APP)"
		RET=1
		;;
	    *)
		echo "Don't know how to install $APP_SUF packages"
		RET=1
		;;
	esac
    fi

    return $RET
}


get_guest_os_for_client_vbox()
{
    CLIENT="$1"

    GUEST_OS_TMP=$(vboxmanage showvminfo "$CLIENT" | grep "Guest OS:" | awk ' {print $3}')

    echo $GUEST_OS_TMP
    return 0
}


get_guest_os_for_client()
{
    CLIENT="$1"
    get_info_for_client "$CLIENT"

    export GUEST_OS=""

    case $VM_TYPE in
	"VirtualBox")
	    GUEST_OS=$(get_guest_os_for_client_vbox "$CLIENT")
	    RET=$?
	    ;;
	"qemu")
	    echo "QEMU get_guest_os_for_client()"
	    RET=1
	    ;;
	
	"Android")
	    echo "Android get_guest_os_for_client()"
	    RET=$?
	    ;;
	
	*)
	    echo "get_guest_os_for_client() not implemented for $VM_TYPE"
	    RET=1
	    ;;
    esac
    
    return $RET
} 


vbox_uninstall_app()
{
    CLIENT=$1
    APP=$2
    MODE=$3

    get_info_for_client "$CLIENT"

    get_guest_os_for_client "$CLIENT"

    
    case $GUEST_OS in
	"Ubuntu")
	    exec_client_command_as_root $CLIENT "dpkg --remove $APP"
	    RET=$?
	    
	    ;;
	"Fedora")
	    echo "Fedora uninstall not implemented"
	    RET=1
	    ;;
	"RedHat")
	    echo "RedHat uninstall not implemented"
	    RET=1
	    ;;
	*)
	    echo "Don't know how to uninstall packages on $GUEST_OS"
	    RET=1
	    ;;
    esac

    return $RET
}


uninstall_app()
{
    CLIENT="$1"
    APP="$2"

    get_info_for_client "$1"

    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    fi
    RET=0
    case $VM_TYPE in
	"VirtualBox")
	    echo "VBOX uninstall app: $APP"
	    vbox_uninstall_app "$CLIENT" "$APP" 
	    RET=$?
	    ;;
	"qemu")
	    echo "QEMU uninstall app: $APP"
	    RET=1
	    ;;
	
	"Android")
	    echo "Android uninstall app on $CLIENT  $APP"
	    android_install_app "$CLIENT" "$APP" "uninstall"
	    RET=$?
	    ;;
	
	*)
	    echo "Screenshots not implemented for $1"
	    RET=1
	    ;;
    esac
    
    return $RET
}


install_app()
{
    CLIENT="$1"
    APP="$2"

    get_info_for_client "$1"


    if [ "$CLIENT_FOUND" = "false" ]
	then
	echo "No client configuration found for machine: $1"
	return 111
    fi
    RET=0
    case $VM_TYPE in
	"VirtualBox")
	    echo "VBOX install app: $APP"
	    vbox_install_app "$CLIENT" "$APP" 
	    RET=1
	    ;;
	"qemu")
	    echo "QEMU install app: $APP"
	    RET=1
	    ;;
	
	"Android")
	    echo "Android install app on $CLIENT  $APP"
	    android_install_app "$CLIENT" "$APP" "install"
	    RET=$?
	    ;;
	
	*)
	    echo "Screenshots not implemented for $1"
	    RET=1
	    ;;
    esac
    
    return $RET
}


print_client_settings()
{
    CLIENT=$1

    get_info_for_client "$1"

    if [ -f $CLI_CONF ]
	then
	cat $CLI_CONF
    else
	echo "Can't find configuration file for $CLIENT"
    fi

    
}
